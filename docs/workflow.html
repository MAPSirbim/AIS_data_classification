<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Workflow</title>

<script src="site_libs/header-attrs-2.6/header-attrs.js"></script>
<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/tabwid-1.0.0/tabwid.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Release Note</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="workflow.html">Processing and Analysis</a>
</li>
<li>
  <a href="global_functions.html">Functions</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Workflow</h1>

</div>


<div id="summary" class="section level1">
<h1>Summary</h1>
<p>This release note aims to describe the AIS processing method hosted in the repository (<a href="https://github.com/MAPSirbim/AIS_data_processing/tree/v1.0.1" class="uri">https://github.com/MAPSirbim/AIS_data_processing/tree/v1.0.1</a>), also available at 10.5281/zenodo.4757505. The processing workflow was developed on historical annotated data of the Adriatic Sea (Mediterannean Sea) and aims to (i) identify individual fishing trips and (ii) classify them on a monthly basis according to 5 predefined gear classes: bottom otter trawl (OTB), pelagic pair trawl (PTM), beam trawl (TBB), purse seine (PS), and “other” fishing (OTHER, including dredges and passive gears). In this repository we also release:</p>
<ul>
<li><p>a small subset of AIS signals broadcasted by a few vessels retrieved from the validated dataset (.csv);</p></li>
<li><p>all the parameters required to process the data, such as the input parameters needed to classify fishing trips (.csv) and the trained Random Forest model (.rds) used to finally assign the gear on a monthly basis and finalized to work in the Adriatic Sea;</p></li>
<li><p>additional spatial layers required by the data processing (.shp).</p></li>
</ul>
<p>
<p>A summary description of these data is provided in the Release data information section. <br></p>
</div>
<div id="input-data" class="section level1">
<h1>Input data</h1>
<p>Input data required to start the workflow are described below. <br></p>
<div id="vessel-data" class="section level2">
<h2>Vessel data</h2>
<p>The workflow was originally created to be applied to AIS data. However, it can be adapted to every positioning data type having the following structure:</p>
<pre class="r"><code>data = read.csv(&quot;data/datatest.csv&quot;)
head(data)</code></pre>
<pre><code>##   MMSI            datetime longitude latitude speed
## 1    1 2015-04-01 17:47:53   13.5027  43.6154   5.3
## 2    1 2015-04-01 17:52:54   13.4914  43.6291  10.2
## 3    1 2015-04-01 17:57:55   13.4914  43.6291  10.2
## 4    1 2015-04-01 18:02:55   13.4952  43.6485  11.0
## 5    1 2015-04-01 18:07:55   13.5068  43.6643  10.3
## 6    1 2015-04-01 18:12:55   13.5175  43.6790   9.5</code></pre>
<p>Where:</p>
<ul>
<li>MMSI (Maritime Mobile Service Identity): is the unique identifier in official AIS data. For privacy purposes, the MMSI was converted into a fake id (e.g., “1”)</li>
<li>date and time: timestamp (in the format of Universal Time Coordinate) of broadcasted positions</li>
<li>latitude and longitude: coordinates of the broadcasted positions (WGS 84)</li>
<li>speed: instantaneous speed over ground (SOG) of the vessel (kn) <br></li>
</ul>
</div>
<div id="spatial-layers" class="section level2">
<h2>Spatial layers</h2>
<p>Three vector layers are required to perform the functions foreseen by the workflow:</p>
<ul>
<li>ports (.shp). Port locations were stored as point buffers or manually designed, to best include approach channels to ports, and described by following attributes: name, country and statistical Area (for our scope we use GFCM Geographical Sub-Area; GSA).</li>
<li>coastal_ban_zone (.shp). Zone where the use of towed gears is prohibited, as defined by Article 13(1) of Regulation (EC) No 1967/2006. It is bounded by 3 nautical miles of the coast or by the 50 m isobath where that depth is reached at a shorter distance from the coast.</li>
<li>grid (.shp). It is the spatial grid used to aggregate fishing effort and estimate fishing hours. The grid provided in this repository is available here.</li>
</ul>
<p>
<p>These layers cover the Mediterranean basin and should be manually recreated in order to reproduce the processing workflow in different areas. <br></p>
</div>
</div>
<div id="processing" class="section level1">
<h1>Processing</h1>
<p>The proposed workflow is hereafter applied on a single vessel although it can be iterated on multiple vessels.</p>
<pre class="r"><code>vessel = 2
data = data[which(data$MMSI == vessel),]
head(data)</code></pre>
<pre><code>##      MMSI            datetime longitude latitude speed
## 8858    2 2018-06-03 21:41:39   13.5002  43.6224   9.0
## 8859    2 2018-06-03 21:48:44   13.4905  43.6308   5.6
## 8860    2 2018-06-03 21:53:48   13.4836  43.6385   9.0
## 8861    2 2018-06-03 21:56:49   13.4768  43.6463  11.1
## 8862    2 2018-06-03 21:59:51   13.4693  43.6544  11.1
## 8863    2 2018-06-03 22:05:55   13.4540  43.6698  11.1</code></pre>
<div id="fishing-trip" class="section level2">
<h2>Fishing trip</h2>
<p>The create_fishing_trip function identifies vessel-specific fishing trips for each vessel, as sequences of points broadcasted by a vessel, from the time it leaves the port until it returns. To run the function, four datasets are required to complete the entire workflow: the sequence of AIS positions of a vessel, the coastal_ban_zone layer, and 2 layers related to the ports. As AIS transmission gaps (loss of signal of at least 30 minutes) can hamper the identification of the departure and arrival ports, a recovery function was internally applied to join consecutive trips where the departure/arrival port was too far to be assigned. In order to join consecutive trips the function overlays the ending/starting points with the coastal_ban_zone, compares ids between consecutive ending/starting points, compares timestamps and forces a starting and ending port for each trip. In particular, fishing trips are joined and the nearest port is assigned if ending and starting points are consecutive, have a temporal distance shorter than 24 h and at least one is outside the coastal_ban_zone. At the end of the recovery process, for trips that still miss departure and/or arrival ports, the internal function closest_port_recovery is used to force port assignment under other conditions.</p>
<pre class="r"><code>dat_session= create_fishing_trip(data, 
                                 ports,  
                                 ports_buffer, 
                                 coastal_ban_zone, 
                                 results_table = F)</code></pre>
<p><br></p>
<ul>
<li>data: AIS positions</li>
<li>ports: port locations (.shp)</li>
<li>ports_buffer: 1 km buffer, created around the input ports (.shp)</li>
<li>coastal_ban_zone: zone where the use of towed gears is prohibited (.shp)</li>
</ul>
<p>
<p>The create_fishing_trip function returns the fishing trip table, listing all the trips performed by the vessel and providing information on: departure/arrival timestamps and departure/arrival port names.</p>
<p>The fishing trip table created above is required to assign the fishing trip id to the AIS signals of the vessels. However, the fishing trip table can be useful to store summary information of the fishing trips of a vessel and used to recall records belonging to single trips by using the starting and ending timestamp. In addition, it may be linked with the port layer where information regarding the country and GSA is stored.</p>
<p>
<p>The function assign_trip assigns to each AIS position the trip to which it belongs.</p>
<pre class="r"><code>dat_with_trip = assign_trip(data, 
                               trip_table)
head(dat_with_trip)</code></pre>
<p><br></p>
<ul>
<li>data: AIS positions</li>
<li>trip_table: dataframe containing the list of fishing trips and the relative timestamp information (output of the create_fishing_trip function)</li>
</ul>
<p>
<p>The assign_trip function returns the AIS data indexed with trip information</p>
</div>
<div id="fishing-trip-classification-and-gear-assignment" class="section level2">
<h2>Fishing trip classification and gear assignment</h2>
<p>The classification_wrapper function applies a cascade of classification algorithms on each fishing trip, using as input the AIS positions with their assigned trip (dat_with_trip) and the specific parameters needed for each classification algorithm (pars). The classification of each fishing trip is done by two internal functions (classify_speed and search_cluster), whose results are used to label each fishing point according to the speed clusters (in the case of towed gears) or spatial clusters (in the case of PS).</p>
<p>
<p>In particular, a k-means algorithms is performed on trip-specific speed values using 5 different sets of centroids that were a priori defined by experts for each fishing gear type (two for OTB, PTM, TBB and PS), the centroids will represent the different speed profiles of fishing behavioural states. The dbscan algorithm is applied on the latitude and longitude data, with two different sets of neighborhood radii (ε) and a number of minimum points in the ε region. The proportions of points falling within each of the identified clusters are used to label the fishing trip as positive or negative to each of the investigated gears.</p>
<pre class="r"><code>dat_classified=classification_wrapper(vessel_data, 
                                      pars, 
                                      write.output = F, 
                                      output.name=F)</code></pre>
<p><br></p>
<ul>
<li>dat_with_trip: raw AIS data with an additional column indexing the corresponding fishing trip</li>
<li>pars: table of parameters required by the classification functions;</li>
<li>write.output: logical argument to store the data needed to train the Random Forest model.</li>
<li>output.name: logical argument, specify the name to be given to the output file.</li>
</ul>
<p>
<p>The dat_classified output contains a list with two objects:</p>
<ul>
<li><p>“data_labelled”: returns the input data with an additional column for each classification algorithm, indicating the speed cluster assigned by the k-means (in the case of towed gears: otb1, otb2, tbb, ptm) or the spatial cluster assigned by the dbscan (in the case of ps). Clusters 1-2 refer to data gaps or noise, while clusters 3-6 indicate different fishing behavioural states (e.g., hauling, searching, steaming). Besides, a column specifying the month in which the trip started is added.</p></li>
<li><p>“classification_result”: contains the binary results of the classification algorithms for each fishing trip and each classification algorithm (otb1, otb2, ptm, tbb, ps); gaps is the percentage (in respect to the duration of the trip) of AIS shutdowns; n_ping is the number of AIS signals belonging to each trip, and start_month is the month in which the fishing trip starts.</p></li>
</ul>
<p>
<p>In order to accommodate the intra-month variability of the predicted gears, fishing gears are finally reassigned to trips on a monthly basis appling a Random Forest model (RF) using the Random Forest library available in R (Liaw and Viener, 2002). The classification unit of the RF is the set of fishing trips performed in a month by a vessel.</p>
<p>
<p>Before training the RF, 524 known vessels (8463 units) are randomly stratified while splitting up into 2 datasets (90:10, dataset 1 and dataset 2, respectively) according to the number of vessels by gear class. The dataset 1 (7572 units) is further splitted in 70:30 equally portioning among the 5 gears (Training and Validation, respectively) to allow model tuning. The dataset 2 (891 units) is used as a test to evaluate classification performance and transferability of the trained RF. <br></p>
<template id="17bb8662-5852-4e94-8adb-e0408c65db76"><style>
.tabwid table{
  border-collapse:collapse;
  line-height:1;
  margin-left:auto;
  margin-right:auto;
  border-width: 0;
  display: table;
  margin-top: 5px;
  margin-bottom: 5px;
  table-layout: fixed;
  border-spacing: 0;
  border-color: transparent;
}
.tabwid_left table{
  margin-left:0;
}
.tabwid_right table{
  margin-right:0;
}
.tabwid td {
    padding: 0;
}
.tabwid a {
  text-decoration: none;
}
.tabwid thead {
    background-color: transparent;
}
.tabwid tfoot {
    background-color: transparent;
}
.tabwid table tr {
background-color: transparent;
}
</style><div class="tabwid"><style>.cl-f2a40230{border-collapse:collapse;}.cl-f29a6c20{font-family:'DejaVu Sans';font-size:11pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-f29a8728{margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:3pt;padding-top:3pt;padding-left:3pt;padding-right:3pt;line-height: 1;background-color:transparent;}.cl-f29a8750{margin:0;text-align:right;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:3pt;padding-top:3pt;padding-left:3pt;padding-right:3pt;line-height: 1;background-color:transparent;}.cl-f29add68{width:82pt;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29add90{width:89pt;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29adda4{width:76pt;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29addae{width:31pt;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29addc2{width:64pt;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29addcc{width:76pt;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29adde0{width:64pt;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29addea{width:89pt;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29addfe{width:31pt;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29ade08{width:82pt;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29ade1c{width:89pt;background-color:transparent;vertical-align: middle;border-bottom: 2pt solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29ade26{width:82pt;background-color:transparent;vertical-align: middle;border-bottom: 2pt solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29ade3a{width:31pt;background-color:transparent;vertical-align: middle;border-bottom: 2pt solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29ade44{width:64pt;background-color:transparent;vertical-align: middle;border-bottom: 2pt solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29ade4e{width:76pt;background-color:transparent;vertical-align: middle;border-bottom: 2pt solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29ade58{width:89pt;background-color:transparent;vertical-align: middle;border-bottom: 2pt solid rgba(0, 0, 0, 1.00);border-top: 2pt solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29ade6c{width:64pt;background-color:transparent;vertical-align: middle;border-bottom: 2pt solid rgba(0, 0, 0, 1.00);border-top: 2pt solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29ade76{width:76pt;background-color:transparent;vertical-align: middle;border-bottom: 2pt solid rgba(0, 0, 0, 1.00);border-top: 2pt solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29ade8a{width:82pt;background-color:transparent;vertical-align: middle;border-bottom: 2pt solid rgba(0, 0, 0, 1.00);border-top: 2pt solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-f29ade94{width:31pt;background-color:transparent;vertical-align: middle;border-bottom: 2pt solid rgba(0, 0, 0, 1.00);border-top: 2pt solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}</style><table class='cl-f2a40230'><thead><tr style="overflow-wrap:break-word;"><td class="cl-f29ade94"><p class="cl-f29a8728"><span class="cl-f29a6c20">Gear</span></p></td><td class="cl-f29ade58"><p class="cl-f29a8750"><span class="cl-f29a6c20">Dataset.1.(num..vessels)</span></p></td><td class="cl-f29ade76"><p class="cl-f29a8750"><span class="cl-f29a6c20">Training.(num..units)</span></p></td><td class="cl-f29ade8a"><p class="cl-f29a8750"><span class="cl-f29a6c20">Validation.(num..units)</span></p></td><td class="cl-f29ade58"><p class="cl-f29a8750"><span class="cl-f29a6c20">Dataset.2.(num..vessels)</span></p></td><td class="cl-f29ade6c"><p class="cl-f29a8750"><span class="cl-f29a6c20">Test.(num..units)</span></p></td></tr></thead><tbody><tr style="overflow-wrap:break-word;"><td class="cl-f29addae"><p class="cl-f29a8728"><span class="cl-f29a6c20">OTB</span></p></td><td class="cl-f29add90"><p class="cl-f29a8750"><span class="cl-f29a6c20">282</span></p></td><td class="cl-f29adda4"><p class="cl-f29a8750"><span class="cl-f29a6c20">3,265</span></p></td><td class="cl-f29add68"><p class="cl-f29a8750"><span class="cl-f29a6c20">1,403</span></p></td><td class="cl-f29add90"><p class="cl-f29a8750"><span class="cl-f29a6c20">32</span></p></td><td class="cl-f29addc2"><p class="cl-f29a8750"><span class="cl-f29a6c20">516</span></p></td></tr><tr style="overflow-wrap:break-word;"><td class="cl-f29addfe"><p class="cl-f29a8728"><span class="cl-f29a6c20">TBB</span></p></td><td class="cl-f29addea"><p class="cl-f29a8750"><span class="cl-f29a6c20">25</span></p></td><td class="cl-f29addcc"><p class="cl-f29a8750"><span class="cl-f29a6c20">206</span></p></td><td class="cl-f29ade08"><p class="cl-f29a8750"><span class="cl-f29a6c20">91</span></p></td><td class="cl-f29addea"><p class="cl-f29a8750"><span class="cl-f29a6c20">4</span></p></td><td class="cl-f29adde0"><p class="cl-f29a8750"><span class="cl-f29a6c20">83</span></p></td></tr><tr style="overflow-wrap:break-word;"><td class="cl-f29addfe"><p class="cl-f29a8728"><span class="cl-f29a6c20">PTM</span></p></td><td class="cl-f29addea"><p class="cl-f29a8750"><span class="cl-f29a6c20">36</span></p></td><td class="cl-f29addcc"><p class="cl-f29a8750"><span class="cl-f29a6c20">366</span></p></td><td class="cl-f29ade08"><p class="cl-f29a8750"><span class="cl-f29a6c20">162</span></p></td><td class="cl-f29addea"><p class="cl-f29a8750"><span class="cl-f29a6c20">5</span></p></td><td class="cl-f29adde0"><p class="cl-f29a8750"><span class="cl-f29a6c20">87</span></p></td></tr><tr style="overflow-wrap:break-word;"><td class="cl-f29addae"><p class="cl-f29a8728"><span class="cl-f29a6c20">PS</span></p></td><td class="cl-f29add90"><p class="cl-f29a8750"><span class="cl-f29a6c20">93</span></p></td><td class="cl-f29adda4"><p class="cl-f29a8750"><span class="cl-f29a6c20">1,119</span></p></td><td class="cl-f29add68"><p class="cl-f29a8750"><span class="cl-f29a6c20">479</span></p></td><td class="cl-f29add90"><p class="cl-f29a8750"><span class="cl-f29a6c20">10</span></p></td><td class="cl-f29addc2"><p class="cl-f29a8750"><span class="cl-f29a6c20">149</span></p></td></tr><tr style="overflow-wrap:break-word;"><td class="cl-f29ade3a"><p class="cl-f29a8728"><span class="cl-f29a6c20">OTHER</span></p></td><td class="cl-f29ade1c"><p class="cl-f29a8750"><span class="cl-f29a6c20">62</span></p></td><td class="cl-f29ade4e"><p class="cl-f29a8750"><span class="cl-f29a6c20">342</span></p></td><td class="cl-f29ade26"><p class="cl-f29a8750"><span class="cl-f29a6c20">139</span></p></td><td class="cl-f29ade1c"><p class="cl-f29a8750"><span class="cl-f29a6c20">9</span></p></td><td class="cl-f29ade44"><p class="cl-f29a8750"><span class="cl-f29a6c20">56</span></p></td></tr></tbody></table></div></template>
<div id="51039be6-b489-475e-b674-d84a83ea5b77"></div>
<script>
var dest = document.getElementById("51039be6-b489-475e-b674-d84a83ea5b77");
var template = document.getElementById("17bb8662-5852-4e94-8adb-e0408c65db76");
var caption = template.content.querySelector("caption");
if(caption) {
  caption.style.cssText = "display:block;"
  var newcapt = document.createElement("p");
  newcapt.appendChild(caption)
  dest.parentNode.insertBefore(newcapt, dest.previousSibling);
}
var fantome = dest.attachShadow({mode: 'open'});
var templateContent = template.content;
fantome.appendChild(templateContent);
fantome.appendChild(templateContent);
</script>

<p><br></p>
<p>The decision_gear function uses the trained RF to predict the fishing gear for each month. The features used to predict the monthly gear consist in the ratio between the trips labelled as positive for each gear and the total number of the fishing trips (ratio_otb1; ratio_otb2; ratio_ptm; ratio_tbb; ratio_ps).</p>
<pre class="r"><code>gear = decision_gear(data = dat_classified[[&quot;classification_result&quot;]])</code></pre>
<p><br></p>
<ul>
<li>data: requires the binary results of the classification algorithms for each fishing trip (output of the classification wrapper “dat_classified[["classification_result"]]”).</li>
</ul>
<p>The result of the decision gear function is a summary of the binary results aggregated at monthly level and in addition it gives the output of the RF (i.e., gear).</p>
</div>
<div id="fishing-activity" class="section level2">
<h2>Fishing activity</h2>
<p>According to the monthly predicted gear, fishing points are identified (identify_fishing_points function) recycling the clusters (k-means - towed gears; dbscan - purse seiners) and retrieving points corresponding to fishing clusters.</p>
<pre class="r"><code>fishing_points=identify_fishing_points(data=dat_classified[[&quot;data_labelled&quot;]], gear=gear)
head(fishing_points)</code></pre>
<p><br></p>
<ul>
<li>data: requires AIS data, indexed by fishing trip and labelled with the information from k-means and dbscan (output of the classification wrapper “dat_classified[["data_labelled"]]”).</li>
<li>gear: the result of the decision gear function, containing the gear predicted by the Random Forest classifier</li>
</ul>
<p>
<p>The fishing_point function returns the original AIS data, labelled with the gear identified and with a column (binary) indicating if the points are considered as fishing activity. *POINT is a character codification used instead of the real value of the geometry string</p>
<p>
<p>The make_fishing_tracks function extracts fishing tracks from fishing points, using a temporal threshold (thr_minute, default value set to 30 minutes) to connect successively ordered fishing points ≤ thr_minutes and avoid false fishing tracks connecting two subsequent fishing events. The result of make_fishing_tracks function is a spatial object where the fishing geometries are stored.</p>
<pre class="r"><code>fishing_tracks=make_fishing_tracks(data=fishing_points, coord_sys=wgs, pars=pars)
head(fishing_tracks)</code></pre>
<p><br></p>
<ul>
<li>fishing_points: AIS data labelled with the gear identified and with a column (binary) identifying the data considered as fishing activity</li>
<li>wgs: coordinate reference system (e.g.: WGS 84)</li>
<li>pars: object storing the parameter file.</li>
</ul>
*LINESTRING is a character codification used instead of the real value of the geometry string
<p>
</div>
<div id="single-command-function" class="section level2">
<h2>Single command function</h2>
<p>The classification_workflow function applies all the functions presented in the previous sections in one single command starting from raw data and returns the fishing tracks/centroids of a vessel. The output type parameter allows storing fishing geometries as points or linestrings. <br></p>
<pre class="r"><code>fishing_tracks=classification_workflow(data=data,
                                       ports=ports, 
                                       ports_buffer=port_buf,
                                       coastline=coastline,
                                       pars=pars,
                                       coord_sys=wgs,
                                       output.type=&quot;segments&quot;)</code></pre>
<p><br></p>
<ul>
<li>data: raw AIS data</li>
<li>ports: .shp of the port locations</li>
<li>ports_buffer: is the 1 km buffer calculated from the input ports .shp at the beginning of the workflow.</li>
<li>coastal_ban_zone: .shp of the zone where the use of towed gears is prohibited</li>
<li>wgs: coordinate reference system (e.g.: WGS 84)</li>
<li>pars: object storing the parameter file.</li>
<li>output.type: specify if the output will be the fishing tracks (argument: “tracks”) or the fishing points (argument: “points”). <br></li>
</ul>
</div>
<div id="estimate-fishing-effort" class="section level2">
<h2>Estimate fishing effort</h2>
<p>Finally, the estimate_fishing_effort function returns a grid populated with cumulative fishing time for the period covered by the input data (hours fishing vessels spent operating gear in each grid cell). Fishing tracks were intersected with the 0.1° grid and durations were computed for each output feature. For towed gears, fishing hours are calculated by dividing resulting lengths by the inherited mean fishing speed. For the purse seiners, fishing hours are calculated by assigning the duration of the cluster to its centroid. The cumulative fishing time was quantified spatial joining each cell with overlapping centroid/portions of hauls, and summing relative durations.</p>
<pre class="r"><code>vessel_grid=estimate_fishing_effort(fishing_tracks, grid=grid)</code></pre>
<p><br></p>
<ul>
<li>fishing_tracks: spatial object containing the geometries of the fishing activity</li>
<li>grid: spatial object containing the reticule covering the area of interest that will be intersected with the fishing tracks.</li>
</ul>
<p>
<p>Effort grid and fishing tracks can be plotted in effort maps.</p>
</div>
</div>
<div id="multiple-vessels-with-different-gears" class="section level1">
<h1>Multiple vessels with different gears</h1>
<p>To apply the workflow to multiple vessels and aggregate related fishing activities with different temporal frames (e.g., by year and month), the analysis can be arranged as follow:</p>
<ol style="list-style-type: decimal">
<li><p>Create fishing segments for all vessels and store them in a list. Each element of the list is a vessel, whose data is again stored in a list as long as the number of different gears predicted for that vessel. The classification_workflow function is applied iteratively on all vessels present in the data and it allows to calculate the fishing geometry in one single command.</p></li>
<li><p>Aggregate fishing segments by fishing gear and time period (e.g., month). The first rows of the following code selects all fishing trips that are classified with the same gear. Fishing hours of vessels predicted with the same fishing gear in the same period, are aggregated with respect to a spatial grid to represent the period pattern of spatial activity. In the last rows, grid data is saved in tabular dataframe and in an effort map.</p></li>
</ol>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
